<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习LLVM，并实现中间代码级的指令复算]]></title>
    <url>%2F2018%2F03%2F27%2FLLVMlearning%2F</url>
    <content type="text"><![CDATA[以下记录了通过LLVM实现IR指令复算的关键技术问题。 1 如何插入一条指令参考：https://stackoverflow.com/questions/35198935/add-an-llvm-instruction 12345678BasicBlock *B = I-&gt;getParent();if (auto *op = dyn_cast&lt;BinaryOperator&gt;(&amp;*I)) &#123; auto temp = op-&gt;clone(); B-&gt;getInstList().insert(op, temp); temp-&gt;setName(op-&gt;getName()); op-&gt;replaceAllUsesWith(temp); &#125; 其中，I是Instruction，BinaryOperator是Instruction的子类。 2 如何识别扫描到的指令的类型参考：https://stackoverflow.com/questions/30250289/how-to-check-the-opcode-of-an-instruction 5down voteaccepted isa is used to check for an existing dirived instruction class. class i.getopcode() could help you to get all the operations information. According to the Inheritance diagram for llvm::Instruction,LLVM internally will divide all the instruction into several different classes, like llvm::BinaryOperator, llvm::CallInst, llvm::CmpInst, etc. But there is no exact operation information for these classes. However, for Instruction::getOpcode(), it will directly get the operation from the llvm::Instruction object. You could refer to Instruction.def for an idea about defination of each instruction. Basically, the opcode will be the exact operations the instruction intends to. Say, for an LLVM IR add. You can use isa&lt;llvm::BinaryOperator&gt;, to know that this is a BinaryOperator. But this is only for what the instruction class it is. If you want to know whether it is an ADD or a SUB. i.getopcode() should be used here. 上面给出了几个很好的总结。 Instruction 有多少子类 在http://llvm.org/doxygen/classllvm_1_1Instruction.html 中，有Instruction的继承关系，可以看到Instruction所有的子类 查询每个指令具体属于的操作码，如对于BinaryOperator，具体是ADD还是SUB https://llvm.org/svn/llvm-project/llvm/trunk/include/llvm/IR/Instruction.def 但目前并不知道如何使用这些信息。 使用isa\确定属于哪个子类，使用i.getopcode()确定是子类中的哪个操作 isa(i) and isa(i) without changing to if (i.getopcode()==…) 3. 如何为指令插入Metadata插入字符串类型，借助MDString类，以下为获取每条指令的操作码的名字 12345Value *Elts[] = &#123; MDString::get(context, inst-&gt;getOpcodeName(inst-&gt;getOpcode()))&#125;;MDNode *Node = MDNode::get(context, Elts);temp-&gt;setMetadata("mxk", Node); 插入数字类型 1234std::vector&lt;Value*&gt; llfiindex(1);llfiindex[0] = ConstantInt::get(Type::getInt64Ty(context), fi_index++);MDNode *mdnode = MDNode::get(context, llfiindex);inst-&gt;setMetadata("mxk", mdnode); 删除一条指令的Metadata 12Instruction *temp = inst-&gt;clone();temp-&gt;setMetadata("llfi_index", NULL); 4. 如何更新复算指令的引用为实现代码复算，我们需要为复算指令增加引用，例如： 12%mul = mul nsw i32 %8, %10 原始指令%mul10 = mul nsw i32 %9, %11 副本指令，其use的数据都要更新为原始指令中use数据的副本 为此，我们需要获取每个每个副本指令中需要更新的use数据的信息。 在llvm中，由于采用SSA，所有的数据只会被赋值一次，而且，在数据结构上，所有的数据指针(Value )都是一个指向该数据的指令(Instruction )，注意：Instruction继承自Value和Use。 所以，解决更新副本指令引用的关键，就是找到每个指令所use的数据的副本数据。我们在每条指令的复算过程中，都将原始数据指针（也就是原始指令指针）与副本数据指针（也就是副本数据指针）之间的映射关系存放到map中，这样，我们只需要找到每个指令的所有引用就足以解决问题了。 在https://www.zhihu.com/question/41999500中，给出了很清晰的关于use-def在llvm中如何存储的描述。 llvm的每条指令都存储了def-use信息，结构如下： 对于一个Instruction inst，可以获取其operator的iterator，并且通过for循环遍历之。 123for (User::op_iterator opIterator = temp-&gt;op_begin(); opIterator != temp-&gt;op_end(); opIterator++) &#123; //....&#125; 同时，Use类中，还有一个方法： 123public: /// Normally Use will just implicitly convert to a Value* that it holds. operator Value*() const &#123; return Val; &#125; 也就是说，Use的值会自动转换成一个Value的指针。 所以，我们可以通过opIterator来获取当前指令的所有引用信息。 实现复算和更新副本指令引用的代码如下： 12345678910111213141516171819202122232425BasicBlock *B = inst-&gt;getParent();Instruction *temp = inst-&gt;clone();temp-&gt;setMetadata("llfi_index", NULL);shadow_value_map.insert(std::make_pair&lt;Value*, Value*&gt;(inst, temp));std::vector&lt;Value*&gt; Elts(1);for (User::op_iterator opIterator = temp-&gt;op_begin(); opIterator != temp-&gt;op_end(); opIterator++) &#123; //Use *newOp = opIterator-&gt;getNext();//the operator's next value should be the duplicated instruction Value *curOp = *opIterator; std::map&lt;Value*, Value*&gt;::iterator it = shadow_value_map.find(curOp); if (it != shadow_value_map.end()) &#123; Value *newOp = it-&gt;second; *opIterator = newOp; Elts.push_back(MDString::get(context, newOp-&gt;getName())); &#125; //*opIterator = *newOp;&#125;MDNode *Node = MDNode::get(context, Elts);temp-&gt;setMetadata("mxk1", Node);B-&gt;getInstList().insertAfter(inst,temp);// inst-&gt;replaceAllUsesWith(temp);temp-&gt;setName(inst-&gt;getName()); 5.复算的范围除了terminitor以外，全部复算，但会出现一些问题。 PHI节点问题 landingpad指令 这是LLVM中的异常处理机制，在复算检验实现过程中，曾出现过如下异常信息 12345678910111213141516171819202122232425LandingPadInst not the first non-PHI instruction in the block. %21 = landingpad &#123; i8*, i32 &#125; personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) cleanup, !mxk1 !2, !mxk !64, !numuses !4Broken module found, compilation aborted!0 opt 0x00000000018707fa llvm::sys::PrintStackTrace(_IO_FILE*) + 531 opt 0x0000000001870a8a2 opt 0x00000000018704533 libpthread.so.0 0x00007f3b2999f3904 libc.so.6 0x00007f3b28d58428 gsignal + 565 libc.so.6 0x00007f3b28d5a02a abort + 3626 opt 0x000000000175e9eb7 opt 0x000000000175e69f8 opt 0x0000000001734ff8 llvm::FPPassManager::runOnFunction(llvm::Function&amp;) + 3309 opt 0x000000000173516e llvm::FPPassManager::runOnModule(llvm::Module&amp;) + 12010 opt 0x000000000173546e11 opt 0x0000000001735966 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) + 26212 opt 0x0000000001735b3f llvm::legacy::PassManager::run(llvm::Module&amp;) + 3913 opt 0x00000000008f3828 main + 580414 libc.so.6 0x00007f3b28d43830 __libc_start_main + 24015 opt 0x00000000008e4ef9 _start + 41Stack dump:0. Program arguments: /home/xiaofengwo/llvm/llvm-3.4/build/bin/opt -load /home/xiaofengwo/llvm/ir_sihft_llvm_build/bin/../llvm_passes/llfi-passes.so -insttracepass -maxtrace 250 -o /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-profiling.ll /home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll -S 1. Running pass 'Function Pass Manager' on module '/home/xiaofengwo/llvm/llvm-workspace/sample_programs/kakadu_source_flat/llfi/a-llfi_index.ll'.2. Running pass 'Module Verifier' on function '@_ZN13kdu_synthesisC2E14kdu_resolutionP20kdu_sample_allocatorbf'Aborted (core dumped) landingpad 貌似只能是每个基本块的第一条non-PHI指令。因此，我们把landingpad暂时移出复算域。 call指令 如果对call指令也进行2遍调用，会在执行的时候报段错误，可能是由于每调用一次都产生两遍副本，对于最底层的函数调用次数过多导致的。 如果对call指令仅调用1遍，而后对其define的副本进行同步，则有可能导致call指令引用的变量所指向的内存单元仅在原始变量中是有效的，即如果call指令所引用的变量是指针，那么调用过call指令后，副本指针所指向的位置可能没有值。但由于副本指针和原始指针指向同一位置，如果有对这块地址的修改操作，恐怕会有问题。 在EDDI算法中，也无法解决call指令的问题，无论是调用之后再进行同步，还是调用call指令2遍，都不能自动化实现对于黑盒函数调用之后的数据一致性问题。 Todo：考虑对函数进行分析，确定函数是否可以被调用2遍的角度，实现真正的EDDI算法。 StoreInst和AllocaInst 在EDDI算法中，应该对二者进行复算，但由于call指令的潜在威胁，暂时无法实现完全的EDDI算法，只能实现针对寄存器的SWIFT算法。StoreInst 和 AllocaInst 指令不参与复算。 6. 检查校验对于SWIFT算法，校验点插在StoreInst和CallInst，以及branch指令前。 校验点包括比较和跳转，比较指令比较下一条存储或者函数调用将要用到的变量，跳转指令根据比较结果，选择继续执行还是跳转到最后。 但插入跳转指令，会导致基本块结构的调整，在同一个pass里面，遍历时由于跳转，会破坏该结构，因此，暂时采用插入校验函数的方法，比较低效。 Todo：后期将加入重新对基本块进行调整的机制。 每次拆分基本块后，重新从头开始扫描指令可以解决问题，但十分低效，需要一种快速调整iterator并指向当前处理指令的方法。 可选的方法： 可用方法 是否已尝试 结果 分析 比对之后，结果存于cmp变量中，插入具有比对功能的函数调用 未尝试 方法简单，不需要重新划分基本块，不存在iterator失效问题，但执行时性能较差且出错窗口较大 比对之后，结果存于cmp变量中，在当前指令拆分基本块，并插入br rror_detection指令 已尝试 报错，“Instruction does not dominate all uses!” 每次拆分基本块，会是iterator失效，只能重新获取iterator，效率很低。且函数尾部的error_detection标签所处基本块，原本为unreachable，被某处br到后，原本的ret语句不知为何，报错。 比对之后，结果存于cmp变量中，在当前指令拆分基本块，并插入if-then-else，在then中插入错误处理函数 每次拆分基本块，会是iterator失效，只能重新获取iterator，效率很低。]]></content>
      <tags>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现docx文档的版本管理]]></title>
    <url>%2F2018%2F03%2F18%2Fhowtotrackdocxfilewithgit%2F</url>
    <content type="text"><![CDATA[docx文件提交到git很容易，对docx文件实现版本管理的难点在于如何比较其中的差异，方法简要概述如下： 利用pandoc实现将docx文件转成md文件（只能是docx，而不能是doc） 通过git hook，配置pre-commit和post-commit，在git commit时自动调用生成md文件的过程，并将md文件提交到库中 md文件作为docx的副本，且可以通过diff直接查看 参考：https://github.com/vigente/gerardus/wiki/Integrate-git-diffs-with-word-docx-files 1. 安装pandoc2. Tell git how to handle diffs of .docx files. Create or edit file ~/.gitconfig (linux, Mac) or “c:\Documents and Settings\user.gitconfig” (Windows) to add 12345[diff &quot;pandoc&quot;] textconv=pandoc --to=markdown prompt = false[alias] wdiff = diff --word-diff=color --unified=1 In your paper directory, create or edit file .gitattributes (linux, Windows and Mac) to add 1*.docx diff=pandoc You can commit .gitattributes so that it stays with your paper for use in other computers, but you’ll need to edit ~/.gitconfig in every new computer you want to use. 3. 配置git hookThis is only going to work from linux/Mac or Windows running git from a bash shell. Install pandoc. Pandoc is a program to convert between different file formats. It’s going to allow us to convert Word files (.docx) to Markdown (.md). Set up git hooks to enable automatic generation and tracking of Markdown copies of .docx files. Copy these hook files to your git project’s .git/hooks directory and rename them, or soft-link to them with ln -s, and make them executable (chmod u+x *.sh): pre-commit-git-diff-docx.sh -&gt; .git/hooks/pre-commit post-commit-git-diff-docx.sh -&gt; .git/hooks/post-commit Now every time you run git commit, the pre-commit hook will automatically run before you see the window to enter the log message. The hook is a script that makes a copy in Markdown format (.md) of every .docx file you are committing. The post-commit hook then amends the commit adding the .md files.]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用shadowsocks配置系统代理]]></title>
    <url>%2F2018%2F02%2F06%2Finstruction-to-use-shadowsocks-for-system-proxy%2F</url>
    <content type="text"><![CDATA[1. 配置AWS服务器如果没有搭建远端shadowsocks服务器的需求，可以跳过这一步。 （待补充） 申请AWS账号 登陆AWS官方网站https://aws.amazon.com/cn/，并注册账号，需要填写邮箱号，信用卡信息和手机号码，注册时都会进行验证，信用卡会通过预扣费1美元验证，手机号码通过电话输入屏幕显示的即时数字验证。 现在新注册的用户，需要24小时才能完全激活。 配置远端ShadowSocks服务器 ​ ​ 2. 配置本地ShadowSocks客户端 下载ShadowSocks Shadowsocks-4.0.1.zip 配置ShadowSocks 下载后，打开ShadowSocks客户端，配置远端服务器信息。 启用ShadowSocks客户端 正确启动ShadowSocks客户端以后，就打开了一个本地的代理端口1723，本地应用如果需要使用这个代理，还需要进行一定的配置。除了Chrome以外，其它很多程序也可以配置代理，我们主要讲解Chrome的代理配置。 3. 配置Chrome代理 配置Chrome系统代理 在Chrome设置中找到系统代理设置 这个Chrome的代理设置实际上和IE浏览器的代理设置是共享的，设置方法也一样。 依次点击“连接”——“局域网设置”，按照下图配置代理服务器 配置好以后，Chrome就可以通过代理上网了 配置Chrome自动代理 配置好Chrome系统代理后，Chrome所有的访问都将通过代理服务器，一方面增加服务器的压力，占用带宽和流量，另一方面，很多国内的站点，还通过代理服务器访问，会影响上网速度。 下面我们通过Proxy SwitchyOmega这个Chrome扩展程序，配置Chrome自动切换代理功能。 下载Proxy SwitchyOmega。 这一步不做展开，但最便捷的方式是通过Chrome网上应用店搜索下载，这个操作本身就需要使用代理上网。 配置Proxy SwichyOmega。 首先，新建一个通过代理上网的情景模式。 然后，配置auto switch情景模式。 在规则列表中，输入规则列表网址，并点击“立即更新情景模式”，SwitchyOmega会自动下载规则列表，并在下方显示更新。 1https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 选择AutoProxy 全部配置好以后，如下图所示。 记得配置完成后要点击左下方的“应用选项”，使修改生效。 应用auto switch情景模式]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建自己的github]]></title>
    <url>%2F2018%2F01%2F31%2Fhow%20to%20build%20your%20own%20github%2F</url>
    <content type="text"><![CDATA[建立Git环境关联Github操作技巧1. 为本地库添加远程库现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1$ git remote add origin git@github.com:michaelliao/learngit.git]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有用的技术、工具和站点]]></title>
    <url>%2F2018%2F01%2F31%2Flist%20of%20the%20useful%20tools%20and%20sites%2F</url>
    <content type="text"><![CDATA[（持续更新中…） 站点推荐1. Github2. Library Genesis 在这里可以下载到很多计算机类的电子书，而且都是相对清晰的pdf文档。 云服务系列1. AWS2. 七牛云3. 实用技术1. Markdown2. 思维导图 实用工具1. Typora2. ShadowSocks3. FreeMind4. Anaconda5. 010Editor一款集成了python包的软件，不需要考虑包之间的依赖关系，很方便。 Anaconda官方网站]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
        <tag>实用工具</tag>
        <tag>站点推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo在github上建立自己的博客]]></title>
    <url>%2F2018%2F01%2F30%2Fhowtobuildhexoblogingithub%2F</url>
    <content type="text"><![CDATA[1 建立hexo本地站点具体参考https://hexo.io/主要步骤：1hexo init 1hexo g 1hexo s 默认端口为4000，如果该端口被占用，可以通过hexo s -p 8080将端口改为8080 2 配置主题在https://hexo.io/themes/ 中选择适合自己的主题，并copy到themes文件夹以下以next主题为例 3 配置github自动部署参考https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/主要步骤：修改站点根目录下的_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 民科小屋subtitle: 计算机民科description:author: xiaofengwolanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://ifuleyou.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 15# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:ifuleyou/ifuleyou.github.io.git branch: mastersearch: path: search.xml field: post format: html limit: 10000 4 配置评论、评分、访问计数在themes/next/_config.yml里修改以下配置并且按照配置文件中给出的站点到相应的网站中注册账号，获取相应信息 1234567891011121314151617181920# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: xxxx color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: xxxxx app_key: xxxxxxxx# Disqusdisqus: enable: true shortname: xiaofengwo count: true 5 如何为next主题添加背景效果next主题有一个十分有趣的js背景效果，可以跟随鼠标的移动，汇集背景中随机浮动的点，并在每两个点之间生成一条线段，生生灭灭，聚聚散散，科技感十足，特别受广大民科喜欢。 6 为hexo博客插入图片 七牛云存储 首先，到https://www.qiniu.com网站注册账号，需要实名认证。 然后，创建自己的存储空间。 利用图床软件（windows下的uwp图床，mac下的U图床等）将图片上传到自己的存储空间后，获得url，直接利用url访问即可。 此方法的好处，是操作简便，无需关心图片的具体存放，且七牛会为图片进行瘦身，访问速度较快。另外，图片资源不需要存放到hexo的source文件夹下，可以减少本地存储以及git同步时的时间空间开销，也较易于进行跨越博客平台的迁移。 利用hexo-asset-image上传图片 直接摘抄https://www.jianshu.com/p/c2ba9533088a中的步骤 1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 注意:通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 [](/example.jpg)，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是markdown ​]]></content>
      <categories>
        <category>杂项技术</category>
      </categories>
      <tags>
        <tag>杂项技术</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
